{"/home/travis/build/npmtest/node-npmtest-redbird/test.js":"/* istanbul instrument in package npmtest_redbird */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-redbird/lib.npmtest_redbird.js":"/* istanbul instrument in package npmtest_redbird */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_redbird = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_redbird = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-redbird/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-redbird && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_redbird */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_redbird\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_redbird.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_redbird.rollup.js'] =\n            local.assetsDict['/assets.npmtest_redbird.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_redbird.__dirname + '/lib.npmtest_redbird.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-redbird/node_modules/redbird/index.js":"/*eslint-env node */\n'use strict';\nmodule.exports = require('./lib/proxy');\nmodule.exports.docker = require('./lib/docker');\nmodule.exports.etcd = require('./lib/etcd-backend');\n","/home/travis/build/npmtest/node-npmtest-redbird/node_modules/redbird/lib/proxy.js":"/*eslint-env node */\n'use strict';\n\nvar\n  http = require('http'),\n  httpProxy = require('http-proxy'),\n  validUrl = require('valid-url'),\n  parseUrl = require('url').parse,\n  path = require('path'),\n  _ = require('lodash'),\n  bunyan = require('bunyan'),\n  cluster = require('cluster'),\n  hash = require('object-hash'),\n  LRUCache = require(\"lru-cache\"),\n  routeCache = LRUCache({ max: 5000 }),\n  safe = require('safetimeout'),\n  letsencrypt = require('./letsencrypt.js');\n\nvar ONE_DAY = 60 * 60 * 24 * 1000;\nvar ONE_MONTH = ONE_DAY * 30;\n\nfunction ReverseProxy(opts) {\n  if (!(this instanceof ReverseProxy)) {\n    return new ReverseProxy(opts);\n  }\n\n  this.opts = opts = opts || {};\n\n  var log;\n  if (opts.bunyan !== false) {\n    log = this.log = bunyan.createLogger(opts.bunyan || {\n      name: 'redbird'\n    });\n  }\n\n  var _this = this;\n\n  if (opts.cluster && typeof opts.cluster !== 'number' ||  opts.cluster > 32) {\n    throw Error('cluster setting must be an integer less than 32');\n  }\n\n  if (opts.cluster && cluster.isMaster) {\n    for (var i = 0; i < opts.cluster; i++) {\n      cluster.fork();\n    }\n\n    cluster.on('exit', function (worker, code, signal) {\n      // Fork if a worker dies.\n      log && log.error({\n        code: code,\n        signal: signal\n      },\n        'worker died un-expectedly... restarting it.');\n      cluster.fork();\n    });\n  } else {\n    this.resolvers = [this._defaultResolver];\n\n    opts.port = opts.port || 8080;\n\n    if (opts.letsencrypt) {\n      this.setupLetsencrypt(log, opts);\n    }\n\n    if (opts.resolvers) {\n      this.addResolver(opts.resolvers);\n    }\n\n    //\n    // Routing table.\n    //\n    this.routing = {};\n\n    //\n    // Create a proxy server with custom application logic\n    //\n    var proxy = this.proxy = httpProxy.createProxyServer({\n      xfwd: (opts.xfwd != false),\n      prependPath: false,\n      secure: (opts.secure !== false),\n      /*\n      agent: new http.Agent({\n        keepAlive: true\n      })\n      */\n    });\n\n    proxy.on('proxyReq', function (p, req) {\n      if (req.host != null) {\n        p.setHeader('host', req.host);\n      }\n    });\n\n    //\n    // Support NTLM auth\n    //\n    if (opts.ntlm) {\n      proxy.on('proxyRes', function (proxyRes) {\n        var key = 'www-authenticate';\n        proxyRes.headers[key] = proxyRes.headers[key] && proxyRes.headers[key].split(',');\n      });\n    }\n\n    //\n    // Optionally create an https proxy server.\n    //\n    if (opts.ssl) {\n      if (_.isArray(opts.ssl)) {\n        opts.ssl.forEach(function(sslOpts){\n          _this.setupHttpsProxy(proxy, websocketsUpgrade, log, sslOpts);\n        })\n      } else {\n        this.setupHttpsProxy(proxy, websocketsUpgrade, log, opts.ssl);\n      }\n    }\n\n    //\n    // Plain HTTP Proxy\n    //\n    var server = this.setupHttpProxy(proxy, websocketsUpgrade, log, opts);\n\n    server.listen(opts.port);\n\n    proxy.on('error', handleProxyError);\n\n    log && log.info('Started a Redbird reverse proxy server on port %s', opts.port);\n  }\n\n  function websocketsUpgrade(req, socket, head) {\n    var src = getSource(req);\n    var target = _this._getTarget(src, req);\n    log && log.info({ headers: req.headers, target: target }, 'upgrade to websockets');\n    if (target) {\n      proxy.ws(req, socket, head, { target: target });\n    } else {\n      respondNotFound(req, socket);\n    }\n  }\n\n  function handleProxyError(err, req, res) {\n    //\n    // Send a 500 http status if headers have been sent\n    //\n\n    if (err.code === 'ECONNREFUSED') {\n      res.writeHead && res.writeHead(502);\n    } else if (!res.headersSent) {\n      res.writeHead && res.writeHead(500);\n    }\n\n    //\n    // Do not log this common error\n    //\n    if (err.message !== 'socket hang up') {\n      log && log.error(err, 'Proxy Error');\n    }\n\n    //\n    // TODO: if err.code=ECONNREFUSED and there are more servers\n    // for this route, try another one.\n    //\n    res.end(err.code)\n  }\n}\n\nReverseProxy.prototype.setupHttpProxy = function (proxy, websocketsUpgrade, log, opts) {\n  var _this = this;\n  var server = this.server = http.createServer(function (req, res) {\n    var src = getSource(req);\n    var target = _this._getTarget(src, req);\n    if (target){\n      if (shouldRedirectToHttps(_this.certs, src, target, _this)) {\n        redirectToHttps(req, res, target, opts.ssl, log);\n      } else {\n        proxy.web(req, res, { target: target });\n      }\n    } else {\n      respondNotFound(req, res);\n    }\n  });\n\n  //\n  // Listen to the `upgrade` event and proxy the\n  // WebSocket requests as well.\n  //\n  server.on('upgrade', websocketsUpgrade);\n\n  server.on('error', function (err) {\n    log && log.error(err, 'Server Error');\n  });\n\n  return server;\n}\n\nfunction shouldRedirectToHttps(certs, src, target, proxy) {\n  return certs && src in certs && target.sslRedirect && target.host != proxy.letsencryptHost;\n}\n\nReverseProxy.prototype.setupLetsencrypt = function (log, opts) {\n  if (!opts.letsencrypt.path) {\n    throw Error('Missing certificate path for Lets Encrypt');\n  }\n  var letsencryptPort = opts.letsencrypt.port || 3000;\n  letsencrypt.init(opts.letsencrypt.path, letsencryptPort, log);\n\n  opts.resolvers = opts.resolvers || [];\n  this.letsencryptHost = '127.0.0.1:' + letsencryptPort;\n  var targetHost = 'http://' + this.letsencryptHost;\n  var challengeResolver = function (host, url) {\n    if (/^\\/.well-known\\/acme-challenge/.test(url)) {\n      return targetHost + '/' + host;\n    }\n  }\n  challengeResolver.priority = 9999;\n  this.addResolver(challengeResolver);\n}\n\nReverseProxy.prototype.setupHttpsProxy = function (proxy, websocketsUpgrade, log, sslOpts){\n  var _this = this;\n  var https;\n\n  this.certs = this.certs || {};\n\n  var certs = this.certs;\n\n  var ssl = {\n    SNICallback: function (hostname, cb) {\n      if (cb) {\n        cb(null, certs[hostname]);\n      } else {\n        return certs[hostname];\n      }\n    },\n    //\n    // Default certs for clients that do not support SNI.\n    //\n    key: getCertData(sslOpts.key),\n    cert: getCertData(sslOpts.cert)\n  };\n\n  if (sslOpts.ca) {\n    ssl.ca = getCertData(sslOpts.ca, true);\n  }\n\n  if (sslOpts.opts) {\n    ssl = _.defaults(ssl, sslOpts.opts);\n  }\n\n  if (sslOpts.http2) {\n    https = require('spdy');\n    if(_.isObject(sslOpts.http2)){\n      sslOpts.spdy = sslOpts.http2;\n    }\n  } else {\n    https = require('https');\n  }\n\n  var httpsServer = this.httpsServer = https.createServer(ssl, function (req, res) {\n\n    var src = getSource(req);\n\n    var target = _this._getTarget(src, req);\n    if (target) {\n      proxy.web(req, res, { target: target });\n    } else {\n      respondNotFound(req, res);\n    }\n  });\n\n  httpsServer.on('upgrade', websocketsUpgrade);\n\n  httpsServer.on('error', function (err) {\n    log && log.error(err, 'HTTPS Server Error');\n  });\n\n  httpsServer.on('clientError', function (err) {\n    log && log.error(err, 'HTTPS Client  Error');\n  });\n\n  log && log.info('Listening to HTTPS requests on port %s', sslOpts.port);\n  httpsServer.listen(sslOpts.port, sslOpts.ip);\n}\n\nReverseProxy.prototype.addResolver = function (resolver) {\n  if (this.opts.cluster && cluster.isMaster) return this;\n\n  if (!_.isArray(resolver)) {\n    resolver = [resolver];\n  }\n\n  var _this = this;\n  resolver.forEach(function (resolveObj) {\n    if (!_.isFunction(resolveObj)) {\n      throw new Error(\"Resolver must be an invokable function.\");\n    }\n\n    if (!resolveObj.hasOwnProperty('priority')) {\n      resolveObj.priority = 0;\n    }\n\n    _this.resolvers.push(resolveObj);\n  });\n\n  _this.resolvers = _.sortBy(_.uniq(_this.resolvers), function (r) {\n    return -r.priority;\n  });\n\n};\n\nReverseProxy.prototype.removeResolver = function (resolver) {\n  if (this.opts.cluster && cluster.isMaster) return this;\n  // since unique resolvers are not checked for performance,\n  // just remove every existence.\n  this.resolvers = this.resolvers.filter(function (resolverFn) {\n    return resolverFn !== resolver;\n  });\n};\n\nReverseProxy.buildTarget = function (target, opts) {\n  opts = opts || {};\n  target = prepareUrl(target);\n  target.sslRedirect = !opts.ssl || opts.ssl.redirect !== false;\n  target.useTargetHostHeader = opts.useTargetHostHeader === true;\n  return target;\n};\n\n/**\n Register a new route.\n\n @src {String|URL} A string or a url parsed by node url module.\n Note that port is ignored, since the proxy just listens to one port.\n\n @target {String|URL} A string or a url parsed by node url module.\n @opts {Object} Route options.\n */\nReverseProxy.prototype.register = function (src, target, opts) {\n  if (this.opts.cluster && cluster.isMaster) return this;\n\n  if (!src || !target) {\n    throw Error('Cannot register a new route with unspecified src or target');\n  }\n\n  var routing = this.routing;\n\n  src = prepareUrl(src);\n\n  if (opts) {\n    var ssl = opts.ssl;\n    if (ssl) {\n      if (!this.httpsServer) {\n        throw Error('Cannot register https routes without defining a ssl port');\n      }\n\n      if (!this.certs[src.hostname]) {\n        if (ssl.key || ssl.cert || ssl.ca) {\n          this.certs[src.hostname] = createCredentialContext(ssl.key, ssl.cert, ssl.ca);\n        } else if (ssl.letsencrypt) {\n          if (!this.opts.letsencrypt || !this.opts.letsencrypt.path) {\n            console.error('Missing certificate path for Lets Encrypt');\n            return;\n          }\n          this.log && this.log.info('Getting Lets Encrypt certificates for %s', src.hostname);\n          this.updateCertificates(\n            src.hostname,\n            ssl.letsencrypt.email,\n            ssl.letsencrypt.production,\n            this.opts.letsencrypt.renewWithin || ONE_MONTH);\n        } else {\n          // Trigger the use of the default certificates.\n          this.certs[src.hostname] = void 0;\n        }\n      }\n    }\n  }\n  target = ReverseProxy.buildTarget(target, opts);\n\n  var host = routing[src.hostname] = routing[src.hostname] || [];\n  var pathname = src.pathname || '/';\n  var route = _.find(host, { path: pathname });\n\n  if (!route) {\n    route = { path: pathname, rr: 0, urls: [] };\n    host.push(route);\n\n    //\n    // Sort routes\n    //\n    routing[src.hostname] = _.sortBy(host, function (_route) {\n      return -_route.path.length;\n    });\n  }\n\n  route.urls.push(target);\n\n  this.log && this.log.info({ from: src, to: target }, 'Registered a new route');\n  return this;\n};\n\nReverseProxy.prototype.updateCertificates = function (domain, email, production, renewWithin, renew) {\n  var _this = this;\n  return letsencrypt.getCertificates(domain, email, production, renew, this.log).then(function (certs) {\n    if (certs) {\n      var opts = {\n        key: certs.privkey,\n        cert: certs.cert + certs.chain\n      }\n      _this.certs[domain] = tls.createSecureContext(opts).context;\n\n      //\n      // TODO: cluster friendly\n      //\n      var renewTime = (certs.expiresAt - Date.now()) - renewWithin;\n      renewTime = renewTime > 0 ? renewTime : _this.opts.letsencrypt.minRenewTime || 60 * 60 * 1000;\n\n      _this.log && _this.log.info('Renewal of %s in %s days', domain, Math.floor(renewTime / ONE_DAY));\n\n      function renewCertificate() {\n        _this.log && _this.log.info('Renewing letscrypt certificates for %s', domain);\n        _this.updateCertificates(domain, email, production, renewWithin, true);\n      }\n\n      _this.certs[domain].renewalTimeout = safe.setTimeout(renewCertificate, renewTime);\n    } else {\n      //\n      // TODO: Try again, but we need an exponential backof to avoid getting banned.\n      //\n      _this.log && _this.log.info('Could not get any certs for %s', domain);\n    }\n  }, function (err) {\n    console.error('Error getting LetsEncrypt certificates', err);\n  });\n};\n\nReverseProxy.prototype.unregister = function (src, target) {\n  if (this.opts.cluster && cluster.isMaster) return this;\n\n  if (!src) {\n    return this;\n  }\n\n  src = prepareUrl(src);\n  var routes = this.routing[src.hostname] || [];\n  var pathname = src.pathname || '/';\n  var i;\n\n  for (i = 0; i < routes.length; i++) {\n    if (routes[i].path === pathname) {\n      break;\n    }\n  }\n\n  if (i < routes.length) {\n    var route = routes[i];\n\n    if (target) {\n      target = prepareUrl(target);\n      _.remove(route.urls, function (url) {\n        return url.href === target.href;\n      });\n    } else {\n      route.urls = [];\n    }\n\n    if (route.urls.length === 0) {\n      routes.splice(i, 1);\n      var certs = this.certs;\n      if (certs) {\n        if (certs[src.hostname] && certs[src.hostname].renewalTimeout) {\n          safe.clearTimeout(certs[src.hostname].renewalTimeout);\n        }\n        delete certs[src.hostname];\n      }\n    }\n\n    this.log && this.log.info({ from: src, to: target }, 'Unregistered a route');\n  }\n  return this;\n};\n\nReverseProxy.prototype._defaultResolver = function (host, url) {\n  // Given a src resolve it to a target route if any available.\n  if (!host) {\n    return;\n  }\n\n  url = url || '/';\n\n  var routes = this.routing[host];\n  var i = 0;\n\n  if (routes) {\n    var len = routes.length;\n\n    //\n    // Find path that matches the start of req.url\n    //\n    for (i = 0; i < len; i++) {\n      var route = routes[i];\n\n      if (route.path === '/' || startsWith(url, route.path)) {\n        return route;\n      }\n    }\n  }\n};\n\nReverseProxy.prototype._defaultResolver.priority = 0;\n\n/**\n * Resolves to route\n * @param host\n * @param url\n * @returns {*}\n */\nReverseProxy.prototype.resolve = function (host, url) {\n  var route;\n\n  host = host && host.toLowerCase();\n  for (var i = 0; i < this.resolvers.length; i++) {\n    route = this.resolvers[i].call(this, host, url);\n    if (route && (route = ReverseProxy.buildRoute(route))) {\n      // ensure resolved route has path that prefixes URL\n      // no need to check for native routes.\n      if (!route.isResolved || route.path === '/' || startsWith(url, route.path)) {\n        return route;\n      }\n    }\n  }\n};\n\nReverseProxy.buildRoute = function (route) {\n  if (!_.isString(route) && !_.isObject(route)) {\n    return null;\n  }\n\n  if (_.isObject(route) && route.hasOwnProperty('urls') && route.hasOwnProperty('path')) {\n    // default route type matched.\n    return route;\n  }\n\n  var cacheKey = _.isString(route) ? route : hash(route);\n  var entry = routeCache.get(cacheKey);\n  if (entry) {\n    return entry;\n  }\n\n  var routeObject = { rr: 0, isResolved: true };\n  if (_.isString(route)) {\n    routeObject.urls = [ReverseProxy.buildTarget(route)];\n    routeObject.path = '/';\n  } else {\n    if (!route.hasOwnProperty('url')) {\n      return null;\n    }\n\n    routeObject.urls = (_.isArray(route.url) ? route.url : [route.url]).map(function (url) {\n      return ReverseProxy.buildTarget(url, route.opts || {});\n    });\n\n    routeObject.path = route.path || '/';\n  }\n  routeCache.set(cacheKey, routeObject);\n  return routeObject;\n};\n\nReverseProxy.prototype._getTarget = function (src, req) {\n  var url = req.url;\n  var route = this.resolve(src, url);\n\n  if (!route) {\n    this.log && this.log.warn({ src: src, url: url }, 'no valid route found for given source');\n    return;\n  }\n\n  var pathname = route.path;\n  if (pathname.length > 1) {\n    //\n    // remove prefix from src\n    //\n    req._url = url; // save original url\n    req.url = url.substr(pathname.length) || '/';\n  }\n\n  //\n  // Perform Round-Robin on the available targets\n  // TODO: if target errors with EHOSTUNREACH we should skip this\n  // target and try with another.\n  //\n  var urls = route.urls;\n  var j = route.rr;\n  route.rr = (j + 1) % urls.length; // get and update Round-robin index.\n  var target = route.urls[j];\n\n  //\n  // Fix request url if targetname specified.\n  //\n  if (target.pathname) {\n    req.url = path.join(target.pathname, req.url);\n  }\n\n  //\n  // Host headers are passed through from the source by default\n  // Often we want to use the host header of the target instead\n  //\n  if (target.useTargetHostHeader === true) {\n    req.host = target.host;\n  }\n\n  this.log && this.log.info('Proxying %s to %s', src + url, path.join(target.host, req.url));\n\n  return target;\n};\n\nReverseProxy.prototype.close = function () {\n  try {\n    this.server.close();\n    this.httpsServer && this.httpsServer.close();\n  } catch (err) {\n    // Ignore for now...\n  }\n};\n\n//\n// Helpers\n//\nfunction getSource(req) {\n  if (req.headers.host) {\n    return req.headers.host.split(':')[0];\n  }\n}\n\n/**\n  Routing table structure. An object with hostname as key, and an array as value.\n  The array has one element per path associated to the given hostname.\n  Every path has a Round-Robin value (rr) and urls array, with all the urls available\n  for this target route.\n\n  {\n    hostA :\n      [\n        {\n          path: '/',\n          rr: 3,\n          urls: []\n        }\n      ]\n  }\n*/\n\nvar respondNotFound = function (req, res) {\n  res.statusCode = 404;\n  res.write('Not Found');\n  res.end();\n};\n\nReverseProxy.prototype.notFound = function (callback) {\n  if (typeof callback == \"function\")\n    respondNotFound = callback;\n  else\n    throw Error('notFound callback is not a function');\n};\n\n//\n// Redirect to the HTTPS proxy\n//\nfunction redirectToHttps(req, res, target, ssl, log) {\n  req.url = req._url || req.url; // Get the original url since we are going to redirect.\n\n  var targetPort = ssl.redirectPort || ssl.port;\n  var hostname = req.headers.host.split(':')[0] + ( targetPort ? ':' + targetPort : '' );\n  var url = 'https://' + path.join(hostname, req.url);\n  log && log.info('Redirecting %s to %s', path.join(req.headers.host, req.url), url);\n  //\n  // We can use 301 for permanent redirect, but its bad for debugging, we may have it as\n  // a configurable option.\n  //\n  res.writeHead(302, { Location: url });\n  res.end();\n}\n\nfunction startsWith(input, str) {\n  return input.slice(0, str.length) === str &&\n    (input.length === str.length || input[str.length] === '/')\n}\n\nfunction prepareUrl(url) {\n  url = _.clone(url);\n  if (_.isString(url)) {\n    url = setHttp(url);\n\n    if (!validUrl.isHttpUri(url) && !validUrl.isHttpsUri(url)) {\n      throw Error('uri is not a valid http uri ' + url);\n    }\n\n    url = parseUrl(url);\n  }\n  return url;\n}\n\nfunction getCertData(pathname, unbundle) {\n  var fs = require('fs');\n\n  // TODO: Support input as Buffer, Stream or Pathname.\n\n  if (pathname) {\n    if (_.isArray(pathname)) {\n      var pathnames = pathname;\n      return _.flatten(_.map(pathnames, function (_pathname) {\n        return getCertData(_pathname, unbundle);\n      }));\n    } else if (fs.existsSync(pathname)) {\n      if (unbundle) {\n        return unbundleCert(fs.readFileSync(pathname, 'utf8'));\n      } else {\n        return fs.readFileSync(pathname, 'utf8');\n      }\n    }\n  }\n}\n\n/**\n Unbundles a file composed of several certificates.\n http://www.benjiegillam.com/2012/06/node-dot-js-ssl-certificate-chain/\n */\nfunction unbundleCert(bundle) {\n  var chain = bundle.trim().split('\\n');\n\n  var ca = [];\n  var cert = [];\n\n  for (var i = 0, len = chain.length; i < len; i++) {\n    var line = chain[i].trim();\n    if (!(line.length !== 0)) {\n      continue;\n    }\n    cert.push(line);\n    if (line.match(/-END CERTIFICATE-/)) {\n      var joined = cert.join('\\n');\n      ca.push(joined);\n      cert = [];\n    }\n  }\n  return ca;\n}\n\nvar tls = require('tls');\nfunction createCredentialContext(key, cert, ca) {\n  var opts = {};\n\n  opts.key = getCertData(key);\n  opts.cert = getCertData(cert);\n  if (ca) {\n    opts.ca = getCertData(ca, true);\n  }\n\n  var credentials = tls.createSecureContext(opts);\n\n  return credentials.context;\n}\n\n//\n// https://stackoverflow.com/questions/18052919/javascript-regular-expression-to-add-protocol-to-url-string/18053700#18053700\n// Adds http protocol if non specified.\nfunction setHttp(link) {\n  if (link.search(/^http[s]?\\:\\/\\//) === -1) {\n    link = 'http://' + link;\n  }\n  return link;\n}\n\nmodule.exports = ReverseProxy;\n","/home/travis/build/npmtest/node-npmtest-redbird/node_modules/redbird/lib/letsencrypt.js":"/**\n * Letsecript module for Redbird (c) Optimalbits 2016\n *\n *\n *\n */\nvar letsencrypt = require('letsencrypt');\n\n/**\n *  LetsEncrypt certificates are stored like the following:\n *\n *  /example.com\n *    /\n *\n *\n *\n */\nvar leStoreConfig = {};\nvar webrootPath = ':configDir/:hostname/.well-known/acme-challenge';\n\nfunction init(certPath, port, logger){\n  var http = require('http');\n  var path = require('path');\n  var url = require('url');\n  var fs = require('fs');\n\n  logger && logger.info('Initializing letsencrypt, path %s, port: %s', certPath, port);\n\n  leStoreConfig = {\n    configDir: certPath,\n    privkeyPath: ':configDir/:hostname/privkey.pem',\n    fullchainPath: ':configDir/:hostname/fullchain.pem',\n    certPath: ':configDir/:hostname/cert.pem',\n    chainPath: ':configDir/:hostname/chain.pem',\n\n    workDir: ':configDir/letsencrypt/var/lib',\n    logsDir: ':configDir/letsencrypt/var/log',\n\n    webrootPath: webrootPath,\n    debug: false\n  }\n\n  // we need to proxy for example: 'example.com/.well-known/acme-challenge' -> 'localhost:port/example.com/'\n  http.createServer(function (req, res){\n    var uri = url.parse(req.url).pathname;\n    var filename = path.join(certPath, uri);\n\n    logger && logger.info('LetsEncrypt CA trying to validate challenge %s', filename);\n\n    fs.exists(filename, function(exists) {\n      if (!exists){\n        res.writeHead(404, {\"Content-Type\": \"text/plain\"});\n        res.write(\"404 Not Found\\n\");\n        res.end();\n        return;\n      }\n\n      res.writeHead(200);\n      fs.createReadStream(filename, \"binary\").pipe(res);\n    });\n  }).listen(port);\n}\n\n/**\n *  Gets the certificates for the given domain.\n *  Handles all the LetsEncrypt protocol. Uses\n *  existing certificates if any, or negotiates a new one.\n *  Returns a promise that resolves to an object with the certificates.\n *  TODO: We should use something like https://github.com/PaquitoSoft/memored/blob/master/index.js\n *  to avoid\n */\nfunction getCertificates(domain, email, production, renew, logger){\n  var LE = require('letsencrypt');\n  var le;\n\n  // Storage Backend\n  var leStore = require('le-store-certbot').create(leStoreConfig);\n\n  // ACME Challenge Handlers\n  var leChallenge = require('le-challenge-fs').create({\n    webrootPath: webrootPath,\n    debug: false\n  });\n\n  le = LE.create({\n    server: production ?  LE.productionServerUrl : LE.stagingServerUrl,\n    store: leStore,                                          // handles saving of config, accounts, and certificates\n    challenges: { 'http-01': leChallenge },                  // handles /.well-known/acme-challege keys and tokens\n    challengeType: 'http-01',                                // default to this challenge type\n    debug: false,\n    log: function (debug) {\n      logger && logger.info(arguments, 'Lets encrypt debugger');\n    }\n  });\n\n  // Check in-memory cache of certificates for the named domain\n  return le.check({ domains: [domain] }).then(function (cert){\n    var opts = {\n      domains: [domain],\n      email: email,\n      agreeTos: true,\n      rsaKeySize: 2048,                                       // 2048 or higher\n      challengeType: 'http-01'\n    }\n\n    if (cert){\n      if (renew){\n        logger && logger.info('renewing cert for ' + domain);\n        opts.duplicate = true;\n        return le.renew(opts, cert).catch(function(err){\n          logger && logger.error(err, 'Error renewing certificates for ', domain);\n        });\n      } else {\n        logger && logger.info('Using cached cert for ' + domain);\n        return cert;\n      }\n    } else {\n      // Register Certificate manually\n      logger && logger.info('Manually registering certificate for %s', domain);\n      return le.register(opts).catch(function (err) {\n        logger && logger.error(err, 'Error registering LetsEncrypt certificates');\n      });\n    }\n  });\n}\n\nmodule.exports.init = init;\nmodule.exports.getCertificates = getCertificates;\n","/home/travis/build/npmtest/node-npmtest-redbird/node_modules/redbird/lib/docker.js":"/*eslint-env node */\n'use strict';\n\n/**\n\tRedbird Docker Module.\n\n\tThis module handles automatic regitration and de-registration of\n\tservices running on docker containers.\n*/\nvar Dolphin = require('dolphin');\n\nfunction DockerModule(redbird, url) {\n  if (!(this instanceof DockerModule)) {\n    return new DockerModule(redbird, url);\n  }\n\n  this.redbird = redbird;\n  var log = redbird.log;\n\n  var targets = this.targets = {};\n  this.ports = {};\n\n  //\n  // We keep an up-to-date table with all the images having\n  // containers running on the system.\n  //\n  var images = this.images = {};\n  var dolphin = this.dolphin = new Dolphin(url);\n\n  var _this = this;\n\n  function registerIfNeeded(imageName, containerId, containerNames) {\n    var image = images[imageName] = images[imageName] || {};\n    var target = targets[imageName];\n\n    if (target && image[containerId] !== 'running') {\n      log && log.info('Registering container %s for target %s', containerId, target.src);\n      _this.registerContainer(target.src, containerId, target.opts);\n    }\n    image[containerId] = 'running';\n  }\n\n  //\n  // Start docker event listener\n  //\n  this.events = dolphin.events();\n\n  this.events.on('connected', function () {\n    //\n    //  Fetch all running containers and register them if\n    //  necessary.\n    //\n    dolphin.containers({ filters: {status:[\"running\"]} }).then(function (containers) {\n      for (var i = 0; i < containers.length; i++) {\n        var container = containers[i];\n        registerIfNeeded(container.Image, container.Id, container.Names);\n      }\n    });\n  });\n\n  this.events.on('event', function (evt) {\n    var image, target;\n\n    log && log.info('Container %s changed to status %s', evt.id, evt.status);\n\n    switch (evt.status) {\n      case 'start':\n      case 'restart':\n      case 'unpause':\n        registerIfNeeded(evt.from, evt.id);\n        break;\n      case 'stop':\n      case 'die':\n      case 'pause':\n        image = images[evt.from];\n        target = targets[evt.from];\n        if (image) {\n          if (image[evt.id] === 'running' && target && _this.ports[evt.id]) {\n            log && log.info('Un-registering container %s for target %s', evt.id, target.src);\n            _this.redbird.unregister(target.src, _this.ports[evt.id]);\n          }\n          image[evt.id] = 'stopped';\n        }\n        break;\n      default:\n      // Nothing\n    }\n  });\n\n  this.events.on('error', function (err) {\n    log && log.error(err, 'dolphin docker event error');\n  });\n}\n\n/**\n\n  Register route from a source to a given target.\n  The target should be an image name. Starting several containers\n  from the same image will automatically deliver the requests\n  to each container in a round-robin fashion.\n\n*/\nDockerModule.prototype.register = function (src, target, opts) {\n  if (this.targets[target]) {\n    throw Error('Cannot register the same target twice');\n  }\n\n  this.targets[target] = {\n    src: src,\n    opts: opts\n  };\n\n  var _this = this;\n  var image = this.images[target];\n  if (image) {\n    for (var containerId in image) {\n      if (image[containerId] === 'running') {\n        this.registerContainer(src, containerId, opts);\n      }\n    }\n  }\n};\n\nDockerModule.prototype.registerContainer = function (src, containerId, opts) {\n  var _this = this;\n  containerPort(this.dolphin, containerId).then(function (targetPort) {\n    _this.redbird.register(src, targetPort, opts);\n    _this.ports[containerId] = targetPort;\n  });\n};\n\nfunction containerPort(dolphin, containerId) {\n  return dolphin.containers.inspect(containerId).then(function (container) {\n    var port = Object.keys(container.NetworkSettings.Ports)[0].split('/')[0];\n    var ip = container.NetworkSettings.IPAddress;\n    if (port && ip) {\n      return 'http://' + ip + ':' + port;\n    } else {\n      throw Error('No valid address or port ' + container.IPAddress + ':' + port);\n    }\n  });\n}\n\nmodule.exports = DockerModule;\n","/home/travis/build/npmtest/node-npmtest-redbird/node_modules/redbird/lib/etcd-backend.js":"/*eslint-env node */\n'use strict';\n\n/**\n\tRedbird ETCD Module\n\tThis module handles automatic proxy registration via etcd\n*/\nvar Etcd = require('node-etcd');\n\nfunction ETCDModule(redbird, options){\n  if (!(this instanceof ETCDModule)){\n    return new ETCDModule(redbird, options);\n  }\n\n  // Create Redbird Instance and Log\n  this.redbird = redbird;\n  var log = redbird.log;\n  var _this = this;\n\n  // Create node-etcd Instance\n  this.etcd = new Etcd(options.hosts,options.ssloptions);\n  this.etcd_dir = (typeof options.path !== 'undefined') ? options.path : \"redbird\";\n\n  // Create directory if not created\n  this.etcd.get(this.etcd_dir,function(err, body, header){\n    if (err && err.errorCode == 100){\n      _this.etcd.mkdir(_this.etcd_dir, function(err){\n        if (err){\n          log.error(err, 'etcd backend error');\n        }\n        else{\n          createWatcher();\n        }\n      });\n    }\n    else if(!err && body.node.dir){\n      createWatcher();\n    }\n    else{\n      log.error(err, 'etcd backend error');\n    }\n  });\n\n  // Helper function to check if values contain settings\n  function IsJsonString(str) {\n      try {\n          JSON.parse(str);\n      } catch (e) {\n          return false;\n      }\n      return true;\n  }\n\n  // Helper function to pretify etcd directory strings\n  function removeEtcDir(str) {\n    return str.replace(_this.etcd_dir, '').replace(/^\\/+|\\/+$/g, '');\n  }\n\n  function createWatcher(){\n    // Watch etcd directory\n    _this.watcher = _this.etcd.watcher(_this.etcd_dir, null, {recursive:true});\n\n    // On Add/Update\n    _this.watcher.on(\"change\", function(body,headers){\n      if(body.node.key && body.node.value && !IsJsonString(body.node.value)){\n        _this.redbird.register(removeEtcDir(body.node.key),body.node.value);\n      }\n      else if(body.node.key && body.node.value && IsJsonString(body.node.value)){\n        var config = JSON.parse(body.node.value);\n        if (typeof config.docker !== 'undefined'){\n          require('../').docker(_this.redbird).register(body.node.key,body.node.value.docker,body.node.value);\n        }\n        else {\n          _this.redbird.register(removeEtcDir(body.node.key),config.hosts,config);\n        }\n      }\n    });\n\n    // On Delete\n    _this.watcher.on(\"delete\", function(body,headers){\n      if(body.node.key){\n        _this.redbird.unregister(removeEtcDir(body.node.key));\n      }\n    });\n\n    // Handle Errors\n    _this.watcher.on(\"error\", function(err){\n      log.error(err, 'etcd backend error');\n    });\n  }\n}\n\nmodule.exports = ETCDModule;\n","/home/travis/build/npmtest/node-npmtest-redbird/node_modules/redbird/gulpfile.js":"/*eslint-env node */\n'use strict';\n\nvar gulp = require('gulp');\nvar eslint = require('gulp-eslint');\n\ngulp.task('lint', function (){\n  // Note: To have the process exit with an error code (1) on\n  // lint error, return the stream and pipe to failOnError last.\n  return gulp.src([\n    './**/*.js',\n    '!./test/**',\n    '!./node_modules/**'\n    ])\n    .pipe(eslint({\n      rules: {\n            'space-after-keywords': [2, 'never'],\n            indent: [2, 2],\n            'valid-jsdoc': 0,\n            'func-style': 0,\n            'no-use-before-define': 0,\n            camelcase: 1,\n            'no-unused-vars': 1,\n            'no-alert': 1,\n            'no-console': 1,\n            'no-unused-expressions': 0,\n            'consistent-return': 0\n        },\n        globals: {\n          'define': true\n        }\n    }))\n    .pipe(eslint.format())\n    .pipe(eslint.failAfterError());\n});\n\n","/home/travis/build/npmtest/node-npmtest-redbird/node_modules/redbird/lib/redis-backend.js":"\"use strict\";\n\nvar redis = require('redis');\nvar Promise = require('bluebird');\nvar _ = require('lodash');\n\nPromise.promisifyAll(redis);\n\n/**\n\tInstantiates a Redis Redbird backend.\n\n\topts: {\n\t\tprefix: '',\n\t\tport: 6739,\n\t\thost: 'localhost',\n\t\topts: {}\n\t}\n*/\nfunction RedisBackend(port, hostname, opts)\n{\n\tif(!(this instanceof RedisBackend)){\n\t\treturn new RedisBackend(port, hostname, opts);\n\t}\n\n\topts = opts || {};\n\tport = port || 6379;\n\thostname = hostname || 'localhost';\n\n\tthis.redis = redis.createClient(port, hostname, opts);\n\tthis.publish = redis.createClient(port, hostname, opts);\n\n\tthis.prefix = opts.prefix + '';\n\n\tthis.baseKey = baseKey(this.prefix);\n}\n\n/**\n\tReturns a Promise that resolves to an array with all the \n\tregistered services and removes the expired ones.\n*/\nRedisBackend.prototype.getServices = function(){\n\tvar _this = this;\n\tvar redis = this.redis;\n\tvar baseKey = this.baseKey;\n\n\t//\n\t// Get all members in the service set.\n\t//\n\treturn redis.smembersAsync(baseKey + 'ids').then(function(serviceIds){\n\t\treturn Promise.all(_.map(serviceIds, function(id){\n\t\t\treturn _this.getService(id);\n\t\t}));\n\t}).then(function(services){\n\t\t// Clean expired services\n\t\treturn _.compact(services);\n\t});\n}\n\nRedisBackend.prototype.getService = function(id){\n\tvar redis = this.redis;\n\t//\n\t// Get service hash\n\t//\n\treturn redis.hgetallAsync(this.baseKey + id).then(function(service){\n\t\tif(service){\n\t\t\treturn service;\n\t\t}else{\n\t\t\t//\n\t\t\t// Service has expired, we must delete it from the service set.\n\t\t\t//\n\t\t\treturn redis.sremAsync(id);\n\t\t}\n\t});\n}\n\nRedisBackend.prototype.register = function(service){\n\tvar redis = this.redis;\n\tvar publish = this.publish;\n\tvar baseKey = this.baseKey;\n\n\t//\n\t// Get unique service ID.\n\t//\n\treturn redis.incrAsync(baseKey + 'counter').then(function(id){\n\t\t// Store it\n\t\tredis.hset(baseKey + id, service).then(function(){\n\t\t\treturn id;\n\t\t})\n\t}).then(function(id){\n\t\t//\n\t\t// // Publish a meesage so that the proxy can react faster to a new registration.\n\t\t//\n\t\treturn publish.publishAsync(baseKey + 'registered', id).then(function(){\n\t\t\treturn id;\n\t\t})\n\t});\n}\n\nRedisBackend.prototype.ping = function(id){\n\treturn this.redis.pexpireAsync(id, 5000);\n}\n\nfunction baseKey(prefix){\n\treturn 'redbird-' + prefix + '-services-';\n}\n\nmodule.exports = RedisBackend;\n\n\n"}